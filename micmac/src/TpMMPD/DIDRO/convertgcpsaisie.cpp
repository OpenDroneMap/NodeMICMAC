#include "StdAfx.h"

std::string TheTypeGCP2DConv = "XXXX";
#define aNbTypeGCP2DConv 5
std::string  TypeGCP2DConv[aNbTypeGCP2DConv] = {"MM2txt","Pix4D2MM","Appui2Homol","MM2PS", "PS2MM"};
std::string aFileOut,aFileIn;
int convertGCPSaisie_Pix4D2MM(int argc,char ** argv);
int exportGCP2DMes2txt(int argc,char ** argv);
int convertGCPSaisie_MM2PS(int argc,char ** argv);
int convertGCPSaisie_PS2MM(int argc,char ** argv);
// goal: convert 2D measure of appuis (from 'saisie appuis' tools ) to homol format
class cAppuis2Homol
{
public:
    cAppuis2Homol(int argc, char** argv);
private:
    cInterfChantierNameManipulateur * mICNM;
    std::string mImPat;
    bool mDebug,mExpTxt,mPMul;
    std::string mHomPackOut, mSH, m2DMesFileName;
};


// markers photoscan
class cMarquerPS
{
public:
    cMarquerPS(int id,std::string label);
    void add2DMeasure(int aIdIm,double U,double V);
    const std::vector<std::string> & locations();
    int Id() const;
    std::string Label() const;
private:
    int mId;
    std::string mLabel;
    std::vector<std::string> m2Dlocation;// string that comply with photoscan <location> tag which contains 2D image measure
};

int GCP2DMeasureConvert_main(int argc,char ** argv)
{

    ELISE_ASSERT(argc >= 2,"Not enough arg");
    TheTypeGCP2DConv = argv[1];

    MMD_InitArgcArgv(argc,argv);

    int ARGC0 = argc;

    //  APRES AVOIR SAUVEGARDER L'ARGUMENT DE TYPE ON LE SUPPRIME
    if (argc>=2)
    {
        argv[1] = argv[0];
        argv++; argc--;
    }

    if (TheTypeGCP2DConv == TypeGCP2DConv[0])
    {
        int aRes = exportGCP2DMes2txt(argc, argv);
        return aRes;
    }
    else if (TheTypeGCP2DConv == TypeGCP2DConv[1])
    {
        int aRes = convertGCPSaisie_Pix4D2MM(argc, argv);
        return aRes;
    }
    else if (TheTypeGCP2DConv == TypeGCP2DConv[2])
    {
        cAppuis2Homol(argc,argv);
        return EXIT_SUCCESS;
    }
    else if (TheTypeGCP2DConv == TypeGCP2DConv[3])
    {
        convertGCPSaisie_MM2PS(argc,argv);
        return EXIT_SUCCESS;
    }
    else if (TheTypeGCP2DConv == TypeGCP2DConv[4])
    {
        convertGCPSaisie_PS2MM(argc,argv);
        return EXIT_SUCCESS;
    }

    bool Error = (ARGC0>=2 ) && (TheTypeGCP2DConv!= std::string("-help"));
    if (Error)
    {
        std::cout << "GCP2DMeasureConvert: ERROR: unknown command : " << TheTypeGCP2DConv << endl;
    }
    std::cout << "Allowed commands are : \n";
    for (int aK=0 ; aK<aNbTypeGCP2DConv ; aK++)
        std::cout << "\t" << TypeGCP2DConv[aK] << "\n";
    if (!Error)
    {
        std::cout << "for details : \n";
        std::cout << "\t GCP2DMeasureConvert MM2txt -help\n";
        std::cout << "\t GCP2DMeasureConvert Pix4D2MM -help\n";
        std::cout << "\t GCP2DMeasureConvert Appui2Homol -help\n";
        std::cout << "\t GCP2DMeasureConvert MM2PS \n";
        std::cout << "\t GCP2DMeasureConvert PS2MM \n";
    }

    return EXIT_FAILURE;
}

int convertGCPSaisie_Pix4D2MM(int argc,char ** argv)
{
    std::string aPat;
    bool aNameDup(0); // for specific case, like the one with 2 flights of camlight or dji uas, that end up with two (or more) images blocs that have the same image name!
    //In this very case Pix4D attribute an Id Label to the image instead of the name. The label is as following: Directory of image/(id).JPG
    std::vector<std::string> aDirFlight;
    std::map<std::string,std::string> KAIm; // associate image label of Pix4D with image dir+name

    ElInitArgMain
            (
                argc,argv,
                LArgMain()
                << EAMC(aFileIn,"txt file from Pix4D soft generated by 'Export Image Marks' process, export format 'Pix4D marks files'",eSAM_IsExistFile),
                LArgMain()  << EAM(aFileOut,"Out",true, "Resulting xml file, 2D-Measurement of GCP in micmac format.")
                << EAM(aPat,"Pat",true, "Image Pattern, to use ONLY in case of several block sharing images that have the same name. In that case images are indexed (id=) by Pix4D.", eSAM_IsPatFile)
                << EAM(aDirFlight,"MulDir",true, "[DirFlight1,DirFlight2,..] List of directory of differents flights, case several block share same image name", eSAM_NoInit)
                );

    if (!MMVisualMode)
    {


        if (EAMIsInit(&aPat) && EAMIsInit(&aDirFlight))
        {
            aNameDup=1;
            std::cout << "Warn, process " << aDirFlight.size() <<"image blocs that are located under different directory.\n";

            for (auto & dir : aDirFlight){
                if (ELISE_fp::IsDirectory(dir))
                {

                    cInterfChantierNameManipulateur * aICNM= cInterfChantierNameManipulateur::BasicAlloc(dir);
                    const std::vector<std::string> aSetIm = *(aICNM->Get(aPat));
                    int it(1);
                    for (auto & im : aSetIm){
                        std::string pix4Dlab=dir+" ("+ToString(it+1)+").JPG";
                        KAIm[pix4Dlab]=dir+im;
                        std::cout << "Pix4D label " << pix4Dlab << " is pointing to image " << KAIm[pix4Dlab] <<"\n";

                        it++;
                    }
                } else { std::cout << "cannot find directory " << dir << ", I skip it.\n";}
            }
        }

        if ((!EAMIsInit(&aPat) && EAMIsInit(&aDirFlight)) || (EAMIsInit(&aPat) && !EAMIsInit(&aDirFlight) )) {
            std::cout << "Warn, multi images blocs option require use of both 'Pat' and 'MulDir'. Abording\n";
            return EXIT_FAILURE;
        }

        if (!EAMIsInit(&aFileOut)) aFileOut=aFileIn.substr(0,aFileIn.size()-4)+"_MM.xml";

        if (ELISE_fp::exist_file(aFileIn))
        {
            ifstream aFile(aFileIn.c_str());
            if(aFile)
            {
                cSetOfMesureAppuisFlottants MAF;
                std::string aLine;

                while(!aFile.eof())
                {
                    getline(aFile,aLine,'\n');

                    if(aLine.size() != 0)
                    {
                        // read line information: Im_Label, GCP_label,U,V   ,DeZoomForMarking,Path2Images
                        char *aBuffer = strdup((char*)aLine.c_str());
                        std::string aImLab = strtok(aBuffer,","); // im lab or im name
                        std::string aGCPLab = strtok( NULL, "," );
                        std::string aU = strtok( NULL, "," );
                        std::string aV = strtok( NULL, "," );

                        if (aNameDup)
                        {
                            if (KAIm.count(aImLab)>0)
                            {aImLab=KAIm[aImLab];} else {std::cout << " cannot link image label " << aImLab << " to an im Name, sorry \n";}
                        }

                        double U,V;
                        FromString(U,aU);
                        FromString(V,aV);

                        // std::cout << "Image name : " << aImLab << " GCP label " << aGCPLab << " U,V: " << U << "," << V << std::endl;

                        // add these to the result
                        cMesureAppuiFlottant1Im aMark;
                        aMark.NameIm()=aImLab;
                        cOneMesureAF1I currentMAF;
                        currentMAF.NamePt()=aGCPLab;
                        currentMAF.PtIm()=Pt2dr(U,V);
                        aMark.OneMesureAF1I().push_back(currentMAF);
                        MAF.MesureAppuiFlottant1Im().push_back(aMark);
                    }
                }
                aFile.close();
                MakeFileXML(MAF,aFileOut);
                std::cout << "Export GCP mark to micmac format, file " << aFileOut << "\n";
            }
            return EXIT_SUCCESS;
        } else {
            std::cout << "Error, cannot find file " << aFileIn << "\n";
            return EXIT_FAILURE;
        }
        // end if MMVisual mode
    }
    return 0;
}



int convertGCPSaisie_PS2MM(int argc,char ** argv)
{

    bool mDebug(0);
    ElInitArgMain
            (
                argc,argv,
                LArgMain()
                << EAMC(aFileIn,"xml file from Photoscan soft generated by 'Export marquers'",eSAM_IsExistFile),
                LArgMain()  << EAM(aFileOut,"Out",true, "Resulting xml file, 2D-Measurement of GCP in micmac format.")
                << EAM(mDebug,"Debug",true, "Debug mode for printing messages in terminal, def false.")
                );

    if (!MMVisualMode)
    {
        if (!EAMIsInit(&aFileOut)) aFileOut=aFileIn.substr(0,aFileIn.size()-4)+"_MM.xml";

        if (ELISE_fp::exist_file(aFileIn))
        {
            ifstream aFile(aFileIn.c_str());
            if(aFile)
            {
                cSetOfMesureAppuisFlottants MAF;
                std::string aLine;
                std::map<int,std::string> Ims;
                std::map<int,std::string> GCPs;
                int imCt(0);

                while(!aFile.eof())
                {
                    getline(aFile,aLine,'\n');

                    if(aLine.size() != 0)
                    {


                        // read camera names and id
                        std::string tagCam("<camera id=");
                        if (aLine.find(tagCam) != string::npos){
                        //if (mDebug) std::cout << "read the tag " << tagCam << "\n";
                        char *aBuffer = strdup((char*)aLine.c_str());

                        std::string tmp = strtok(aBuffer,"\"");
                        std::string idStr = strtok(NULL,"\"");
                        tmp = strtok(NULL,"\"");
                        std::string imName = strtok(NULL,"\"");
                        int id;
                        FromString(id,idStr);
                        Ims[id]=imName;
                        imCt++;
                        if (mDebug) std::cout << "Id: " << id <<  ", camera name: " << imName <<"\n";
                        }

                        // read marquers names and id
                        std::string tagMarq("<marker id=");
                        if (aLine.find(tagMarq) != string::npos){
                        //if (mDebug) std::cout << "read the tag " << tagMarq << "\n";
                        char *aBuffer = strdup((char*)aLine.c_str());

                        std::string tmp = strtok(aBuffer,"\"");
                        std::string idStr = strtok(NULL,"\"");
                        tmp = strtok(NULL,"\"");
                        std::string GCPName = strtok(NULL,"\"");
                        int id;
                        FromString(id,idStr);
                        GCPs[id]=GCPName;

                        if (mDebug) std::cout << "Id: " << id <<  ", GCP name: " << GCPName <<"\n";
                        }


                        // read marquers 2D positions
                        std::string tagMarqEnd("</marker>");
                        std::string tagMarq2("<marker marker_id=");
                        std::string tagNo2DMeas("/>");

                        // double condition: should find the tagMarq2 and not find /> , which means that the GCP exist but that there are no 2D measurements
                        if ((aLine.find(tagMarq2) != string::npos) && (aLine.find(tagNo2DMeas) == string::npos)){

                        //if (mDebug) std::cout << "read the tag " << tagMarq2 << "\n";
                        char *aBuffer = strdup((char*)aLine.c_str());

                        std::string tmp = strtok(aBuffer,"\"");
                        std::string idStr = strtok(NULL,"\"");
                        //std::string end = strtok(NULL,"");

                        int GCPid,imId;
                        std::string imIdStr;
                        FromString(GCPid,idStr);
                        bool test(1);
                        while (test){

                            getline(aFile,aLine,'\n');
                            if (aLine.find(tagMarqEnd) != string::npos){
                            //if (mDebug) std::cout << "read the tag " << tagMarqEnd << "\n";
                            test=0;
                            } else {

                            char *aBuffer = strdup((char*)aLine.c_str());
                            tmp=strtok(aBuffer,"\"");
                            imIdStr=strtok(NULL,"\"");
                            FromString(imId,imIdStr);
                            tmp=strtok(NULL,"\"");
                            tmp=strtok(NULL,"\"");
                            tmp=strtok(NULL,"\"");
                            std::string xStr=strtok(NULL,"\"");
                            tmp=strtok(NULL,"\"");
                            std::string yStr=strtok(NULL,"\"");
                            if (mDebug) std::cout << "Id GCP: " << GCPid <<  ", GCP name: " << GCPs[GCPid] <<  " measured on image " << imId <<  " at position [" << xStr << "," << yStr <<"]\n";
                            double U,V;
                            FromString(U,xStr);
                            FromString(V,yStr);
                            // add these to micmac dictionnarie of GCP measurement
                            cMesureAppuiFlottant1Im aMark;
                            aMark.NameIm()=Ims[imId];
                            cOneMesureAF1I currentMAF;
                            currentMAF.NamePt()=GCPs[GCPid];
                            // position UV start at (0,0) in micmac convention, but at (1,1) in photoscan convention
                            currentMAF.PtIm()=Pt2dr(U-1,V-1);
                            aMark.OneMesureAF1I().push_back(currentMAF);
                            MAF.MesureAppuiFlottant1Im().push_back(aMark);
                            }
                            }

                        }

                    }
                }
                std::cout << "Number of images: " << imCt << "\n";
                aFile.close();
                MakeFileXML(MAF,aFileOut);
                std::cout << "Export GCP mark to micmac format, file " << aFileOut << "\n";
            }
            return EXIT_SUCCESS;
        } else {
            std::cout << "Error, cannot find file " << aFileIn << "\n";
            return EXIT_FAILURE;
        }
        // end if MMVisual mode
    }
    return 0;
}

int exportGCP2DMes2txt(int argc,char ** argv)
{
    ElInitArgMain
            (
                argc,argv,
                LArgMain()
                << EAMC(aFileIn,"xml file of 2D measures in micmac format, as generated by SaisieAppui tools'",eSAM_IsExistFile),
                LArgMain()  << EAM(aFileOut,"Out",true, "Resulting txt file, 2D-Measurement of GCP in txt format.")
                );

    if (!MMVisualMode)
    {
        if (ELISE_fp::exist_file(aFileIn)){

            // name of output
            if (!EAMIsInit(&aFileOut)) aFileOut=aFileIn.substr(0,aFileIn.size()-3)+"txt";
            // open txt output
            FILE * aFOut = FopenNN(aFileOut.c_str(),"w","out");
            fprintf(aFOut,"ImageName GCPName U V markPrecision\n");
            // read input xml file
            cSetOfMesureAppuisFlottants MAF=StdGetFromPCP(aFileIn,SetOfMesureAppuisFlottants);

            for( std::list< cMesureAppuiFlottant1Im >::const_iterator iTmes1Im=MAF.MesureAppuiFlottant1Im().begin();
                 iTmes1Im!=MAF.MesureAppuiFlottant1Im().end();          iTmes1Im++    )
            {
                cMesureAppuiFlottant1Im MAF1im=*iTmes1Im;


                for( std::list< cOneMesureAF1I >::const_iterator iT=MAF1im.OneMesureAF1I().begin();
                     iT!=MAF1im.OneMesureAF1I().end();          iT++    )

                {
                    cOneMesureAF1I gcp=*iT;

                    fprintf(aFOut,"%s %s %f %f %f\n",MAF1im.NameIm().c_str(),gcp.NamePt().c_str(), gcp.PtIm().x, gcp.PtIm().y, gcp.PrecPointe().Val());
                }
            }

        } else {
            std::cout << "I cannot find file " << aFileIn << ", abording.\n";
            return EXIT_FAILURE;
        }

    }
    return 0;
}
/*
cAppuis2Homol::cAppuis2Homol(int argc, char** argv):
    mImPat(""),
    mDebug(0),
    mExpTxt(0),
    mSH("-Appui"),
    mPMul(0)

*/

cAppuis2Homol::cAppuis2Homol(int argc, char** argv):
    mImPat(""),
    mDebug(0),
    mExpTxt(0),
    mPMul(0),
    mSH("-Appui")
{

    ElInitArgMain
            (
                argc,argv,
                LArgMain()
                << EAMC(mImPat, "image pattern",eSAM_IsPatFile)
                << EAMC(m2DMesFileName, "2D measures of GCPs, as results of SaisieAppuiInit ",eSAM_IsExistFile),
                LArgMain()
                << EAM(mDebug,"Debug",true,"Print Messages to help debugging process")
                << EAM(mSH, "SH", true, "Set of Homol postfix, def '-Appui' will write homol to Homol-Appui/ directory")
                << EAM(mExpTxt,"ExpTxt",true,"Save homol as text? default false, mean binary format")
                << EAM(mPMul,"ToNF",true,"Perform conversion of homol dataset to new format of homol (PMul.dat)? def false")
                );

    mICNM=cInterfChantierNameManipulateur::BasicAlloc("./");
    std::vector<std::string> aSetIm = *(mICNM->Get(mImPat));
    std::string aExt("dat");
    if (mExpTxt) aExt="txt";

    std::string aKeyAsocHom = "NKS-Assoc-CplIm2Hom@"+ mSH +"@" + aExt;

    if (mDebug) std::cout << "open 2D mesures\n";
    cSetOfMesureAppuisFlottants aSetOfMesureAppuisFlottants=StdGetFromPCP(m2DMesFileName,SetOfMesureAppuisFlottants);
    if (mDebug) std::cout << "Done\n";

    if (mDebug) std::cout << "Number of MesureAppuiFlottant1Im: " << aSetOfMesureAppuisFlottants.MesureAppuiFlottant1Im().size() << "\n";

    for (auto &aMesAppuisIm1 : aSetOfMesureAppuisFlottants.MesureAppuiFlottant1Im())
    {
        for (auto &aMesAppuisIm2 : aSetOfMesureAppuisFlottants.MesureAppuiFlottant1Im())
        {
           std::string Name1(aMesAppuisIm1.NameIm()), Name2(aMesAppuisIm2.NameIm());
           // check that the image is in the pattern of image given as argument
           std::vector<std::string>::iterator it1;
           it1 = find (aSetIm.begin(), aSetIm.end(), Name1);
           std::vector<std::string>::iterator it2;
           it2 = find (aSetIm.begin(), aSetIm.end(), Name2);

           // in addition image name have to be different
           if ((Name1!=Name2) && (it1 != aSetIm.end()) && (it2 != aSetIm.end())){

           // initialiser le pack de points homologues pour cette paire d'image
            ElPackHomologue  aPackHom;
            int count(0);

            for (auto & OneAppuiIm1 : aMesAppuisIm1.OneMesureAF1I())
            {

                for (auto & OneAppuiIm2 : aMesAppuisIm2.OneMesureAF1I())
                {
                    if (OneAppuiIm1.NamePt()==OneAppuiIm2.NamePt())
                    {
                        if (mDebug) std::cout <<"Name point: " << OneAppuiIm1.NamePt() << "\n";
                        ElCplePtsHomologues Homol(OneAppuiIm1.PtIm(),OneAppuiIm2.PtIm());

                        aPackHom.Cple_Add(Homol);

                        count++;
                    }
                }
            }

           // save homol points
           if (count>0){
           std::string aHomolFile= mICNM->Assoc1To2(aKeyAsocHom, aMesAppuisIm1.NameIm(), aMesAppuisIm2.NameIm(),true);
           aPackHom.StdAddInFile(aHomolFile);
           }
           }
        }
    }

    // convert to new format of homol (alias PMul)
    if (mPMul){
        std::string aCom =    MMBinFile(MM3DStr) + " TestLib ConvNewFH "
                               + mImPat
                               + "  '' "
                               + " SH=" + mSH
                               + " ExpTxt=" + ToString(mExpTxt)
                               ;
        if (mDebug) std::cout << aCom << "\n";
        system_call(aCom.c_str());
    }
}


int convertGCPSaisie_MM2PS(int argc,char ** argv)
{
    ElInitArgMain
            (
                argc,argv,
                LArgMain()
                << EAMC(aFileIn,"xml file of 2D measures in micmac format, as generated by 'SaisieAppui tools'",eSAM_IsExistFile),
                LArgMain()  << EAM(aFileOut,"Out",true, "Resulting txt file, 2D-Measurement of GCP in txt format.")
                );

    if (!MMVisualMode)
    {
        if (ELISE_fp::exist_file(aFileIn)){

            // name of output
            if (!EAMIsInit(&aFileOut)) aFileOut=aFileIn.substr(0,aFileIn.size()-4)+"_MM2PS.xml";

            std::map<std::string,cMarquerPS*> Marquers;
            std::map<std::string,int> aMIms;

            // read input xml file
            cSetOfMesureAppuisFlottants MAF=StdGetFromPCP(aFileIn,SetOfMesureAppuisFlottants);

            // first loop: attribute an id to each GCP, fill container Marquers and container aMIms
            int count(0), countIm(0);
            for( std::list< cMesureAppuiFlottant1Im >::const_iterator iTmes1Im=MAF.MesureAppuiFlottant1Im().begin();
                 iTmes1Im!=MAF.MesureAppuiFlottant1Im().end();          iTmes1Im++    )
            {
                // add image to map
                cMesureAppuiFlottant1Im MAF1im=*iTmes1Im;
                auto searchIm = aMIms.find(MAF1im.NameIm());
                if(searchIm == aMIms.end()) {
                    countIm++;
                    aMIms[MAF1im.NameIm()]=countIm;
                }

                for( std::list< cOneMesureAF1I >::const_iterator iT=MAF1im.OneMesureAF1I().begin();
                     iT!=MAF1im.OneMesureAF1I().end();          iT++    )

                {
                    // add GCP to map
                    cOneMesureAF1I gcp=*iT;
                    auto search = Marquers.find(gcp.NamePt());
                    if(search == Marquers.end()) {
                        count++;
                        Marquers[gcp.NamePt()]=new cMarquerPS(count,gcp.NamePt());
                    }
                }
             }

            // second loop: add 2D measures to each GCP
            for( std::list< cMesureAppuiFlottant1Im >::const_iterator iTmes1Im=MAF.MesureAppuiFlottant1Im().begin();
                 iTmes1Im!=MAF.MesureAppuiFlottant1Im().end();          iTmes1Im++    )
            {
                cMesureAppuiFlottant1Im MAF1im=*iTmes1Im;
                for( std::list< cOneMesureAF1I >::const_iterator iT=MAF1im.OneMesureAF1I().begin();
                     iT!=MAF1im.OneMesureAF1I().end();          iT++    )
                {
                    cOneMesureAF1I gcp=*iT;
                    Marquers[gcp.NamePt()]->add2DMeasure(aMIms[MAF1im.NameIm()],gcp.PtIm().x,gcp.PtIm().y);
                }
             }

            // open txt output
            FILE * aFOut = FopenNN(aFileOut.c_str(),"w","out");
            fprintf(aFOut,"<?xml version='1.0' encoding='UTF-8'?>\n");
            fprintf(aFOut,"<document version='1.1.0'>\n");
            fprintf(aFOut,"<chunk>\n");
            fprintf(aFOut,"<sensors>\n");
            fprintf(aFOut,"<sensor id='0' label='unknown' type='frame'>\n");
            fprintf(aFOut,"<resolution width='5120' height='3840'/>\n");
            fprintf(aFOut,"</sensor>\n </sensors>\n  <cameras>\n");

            for (auto & im : aMIms){
               std::string aLine="<camera id='"+to_string(im.second)+"' label='"+im.first+"' sensor_id='0' />\n";
               fprintf(aFOut, "%s", aLine.c_str());
            }

            fprintf(aFOut,"</cameras>\n  <markers>\n");

            for (auto & GCP : Marquers){
               std::string aLine="<marker id='"+to_string(GCP.second->Id())+"' label='"+GCP.first+"' />\n";
               fprintf(aFOut, "%s", aLine.c_str());
            }

            fprintf(aFOut,"</markers>\n  <frames>\n <frame id='0'> \n  <markers> \n");

            for (auto & GCP : Marquers){
               std::string aLine="<marker marker_id='"+to_string(GCP.second->Id())+"' >\n";
               fprintf(aFOut, "%s", aLine.c_str());
               for (auto & location : GCP.second->locations()){
               fprintf(aFOut,"%s",location.c_str());
               }
               fprintf(aFOut," </marker>\n");
            }
            fprintf(aFOut,"</markers> \n </frame>\n </frames>\n </chunk> \n  </document>\n");
        } else {
            std::cout << "I cannot find file " << aFileIn << ", abording.\n";
            return EXIT_FAILURE;
        }
    }
    return 0;
}



cMarquerPS::cMarquerPS(int id,std::string label):mId(id),mLabel(label){}

void cMarquerPS::add2DMeasure(int aIdIm,double U,double V){
    std::string position;
    // position UV start at (0,0) in micmac convention, but at (1,1) in photoscan convention, so I add 1 to U and V
    position = "<location camera_id='"+to_string(aIdIm)+"' pinned='true' x='"+to_string(U+1.0)+"' y='"+ to_string(V+1.0)+ "' />\n";
    m2Dlocation.push_back(position);
}
const std::vector<std::string> & cMarquerPS::locations(){
    return m2Dlocation;
}
int cMarquerPS::Id() const{
    return mId;
}
std::string cMarquerPS::Label() const{
    return mLabel;
}


#include "cfeatheringandmosaicking.h"

/*
 *
 *
 *     Feather and mosaic for the whole mosaic
 *
 *
 */

c_Appli_FeatheringAndMosaic::c_Appli_FeatheringAndMosaic(int argc,char ** argv)
{

    mLabel="Label.tif";
    mNameMosaicOut="MosaicFeathering.tif";
    mDilat=300;
    mSzTuile=Pt2di(10000,10000);// tile for processing
    mSzTuileFile=Pt2di(25000,25000); // tile for writing result
    mMasqLim=127; // in the mask map, value range from 0 (visible) to 255 (not visible).
    mFileModelsRadiomEgal="RadiomEgalModels.xml";
    mLabel="Label-Feathering.tif";
    mComputeRE=0;

    ElInitArgMain
            (
                argc,argv,
                LArgMain()   << EAMC(mFullDir,"ortho pattern", eSAM_IsPatFile)
                ,
                LArgMain()  << EAM(mNameMosaicOut,"Out",true, "Name of resulting map")
                << EAM(mDist,"Dist",true, "Distance for seamline feathering blending, in chamfer 32 distance" )
                << EAM(mLambda,"Lambda",true, "lambda value for gaussian distance weighting, def 0.4." )
                << EAM(mLabel,"Label",true, "label/index map (tif) previously computed by Tawny. If not provided, generate a new label map based on incidence value" )
                << EAM(mComputeRE,"ComputeRE",true, "Compute Radiometric Egalization models with TestLib EROS. def false" )
                << EAM(mDoRE,"ApplyRE",true, "Apply Radiometric Egalization? require to dertermine models of radiometric equalization beforehand (mm3d TestLib EROS or ComputeRE==1). def false" )
                << EAM(mFileModelsRadiomEgal,"FileRE",true, "Name of xml file with models of Radiometric Egalization, def 'RadiomEgalModels.xml'. " )
                << EAM(mSzTuile,"SzBox",true, "Size [pix] of mosaic tile for multiprocess computation, def=[10000,10000]." )
                << EAM(mSzTuileFile,"SzTile",true, "Size [pix] of mosaic tile for writing result, def=[25000,25000]." )
                << EAM(mDilat,"Buffer",true, "Buffer [pix] to apply for each tile in order to avoid edge effect, def=300." )
                << EAM(mDebug,"Debug",true, "Write intermediate results for debug purpose." )
                << EAM(mTmpDir,"TmpDir",true, "Directory for intermediate results generated in debug mode." )
                );

    if (!MMVisualMode)
    {
        checkParam();
        if (mComputeRE) computeRE();
        std::string aPatOrt;
        SplitDirAndFile(mDir,aPatOrt,mFullDir);
        MakeFileDirCompl(mTmpDir);
        mTmpDir=mDir+mTmpDir;
        mFileModelsRadiomEgal=mDir+mFileModelsRadiomEgal;
        if (!EAMIsInit(&mNameMosaicOut)) mNameMosaicOut=mDir+mNameMosaicOut;
        mICNM = cInterfChantierNameManipulateur::BasicAlloc(mDir);
        mLFile = mICNM->StdGetListOfFile(aPatOrt);
        //mKA=new cMyICNM(mICNM,mTmpDir);

        if(ELISE_fp::IsDirectory(mTmpDir) && mDebug)
        {
            std::cout << "Purge of directory " << mTmpDir << "\n";
            ELISE_fp::PurgeDirGen(mTmpDir,1);
        }
        if(!ELISE_fp::IsDirectory(mTmpDir) && mDebug)
        {
            std::cout << "Create directory " << mTmpDir << "\n";
            ELISE_fp::MkDir(mTmpDir);
        }

        // either use Label already created (by tawny for eg) or generate itself the Table of label
        if (!EAMIsInit(&mLabel))
        {
            mLabel=mDir+mLabel;
            std::cout << "Determine mosaic footprint\n";
            DetermineMosaicFootprint();
            GenLabelTable();
            //label=Im2D_U_INT2::FromFileStd(mLabel);
        } else {
        // load and use an existing label map and set the size/gsd of mosaic footprint accordingly
        if (ELISE_fp::exist_file(mLabel)) {
        std::cout << "Load images label from file " << mLabel << "\n" ;
        label=Im2D_U_INT2::FromFileStd(mLabel);
        std::string aTfwFile(KeyAssocNameTif2TFW(mLabel));
        // look for tfw or MTD file
        if (ELISE_fp::exist_file(aTfwFile))
        {
         MTD =  TFW2FileOriMnt(aTfwFile);
         MTD.NombrePixels()=label.sz();
        } else {
        // if no tfw file, it can still be a label map generated by tawny - MTD are the same than FileOriMnt
        if (ELISE_fp::exist_file("MTDOrtho.xml")){
            MTD = StdGetFromPCP("MTDOrtho.xml",FileOriMnt);
            mBoxGlob=Box2dr(Pt2dr(MTD.OriginePlani().x,MTD.OriginePlani().y+MTD.ResolutionPlani().y*MTD.NombrePixels().y),Pt2dr(MTD.OriginePlani().x+MTD.ResolutionPlani().x*MTD.NombrePixels().x,MTD.OriginePlani().y));
            sz= Pt2di(MTD.NombrePixels().x,MTD.NombrePixels().y);
            aCorner=Pt2dr(mBoxGlob._p0.x,mBoxGlob._p1.y); // xmin, ymax;
        } else { std::cout << "Error, i cannot determine label map footprint because there is neither tfw file nor MTDOrtho.xml\n";}
        }

        } else { std::cout << "Cannot load images label table ; " << mLabel << "\n";}
        }

        if (mDebug) {
            // look up table of weight
            Im1D_REAL4 lut_w=Im1D_REAL4(mDist+1);
            ELISE_COPY
                    (
                        lut_w.all_pts(),
                        0.5+0.5*pow(0.5,pow((FX/((double)mDist-FX+1)),2*mLambda)),
                        lut_w.out()
                        );
            std::cout << "Look up table of weight depending on the distance from seamline\n";
            std::cout << "Blending of two images i and j in the feather buffer is done as follow: in the internal area of image i, weight of image i is 1/2 + 1/2 * Feathering weight display below. \n";
            for (int i(0); i<mDist;i++)
            {
                std::cout << "Feathering weight at Chamfer Dist=" << i << " is equal to " << lut_w.At(i) << "\n";
            };
        }

        std::cout << "Prepare resulting tif files (empty right now)\n";
        GenerateTiff();
        std::cout << "Split mosaic in boxes for parallel processing\n";
        SplitInBoxes();
        std::cout << "Perform the mosaicking for every box of size [pix] " << mSzTuile << ".\n";
        DoMosaicAndFeather(); // for each box
        // rm xml file with image name
        if (!mDebug) for (int i(1);i<=mNbBox;i++) ELISE_fp::RmFileIfExist(mDir+nameXmlImList(i));

        banniereFeathering();
    }
}

void c_Appli_FeatheringAndMosaic::computeRE(){
    std::cout << "Compute radiometric equalization models prior to mosaicking\n";
    std::string aCom =    MMBinFile(MM3DStr) + " TestLib EROS "
            + "'"+ mFullDir + "'  "
            + " Dir=" + mTmpDir
           // + " Debug=" + ToString(mDebug)
            + " Out='" +  mFileModelsRadiomEgal+"'";
            ;
    if (ELISE_fp::exist_file(mFileModelsRadiomEgal)) std::cout << "Warn, file " << mFileModelsRadiomEgal << " exist and will be overwrited\n";
    if (mDebug) std::cout << aCom << "\n";
    system_call(aCom.c_str());
}

void c_Appli_FeatheringAndMosaic::DetermineMosaicFootprint(){

    double xmin(3.4E+38),ymin(3.4E+38),xmax(0),ymax(0),aGSD(0);
    bool first=true;
    for (auto &im : mLFile)
    {
       //std::cout << "open cImGeo " << im << "\n";
       cImGeo ort(mDir+im);
       // Verif that footprint of the MTDOrtho is appropriate for the set (possibly sample) of ortho i want to mosaick
       if (first){
       xmin=ort.Xmin();
       ymin=ort.Ymin();
       xmax=ort.Xmax();
       ymax=ort.Ymax();
       aGSD=ort.GSD();
       first=false;
       } else {
       xmin=ElMin(xmin,ort.Xmin());
       ymin=ElMin(ymin,ort.Ymin());
       xmax=ElMax(xmax,ort.Xmax());
       ymax=ElMax(ymax,ort.Ymax());
       }
    }
    mBoxGlob=Box2dr(Pt2dr(xmin,ymin),Pt2dr(xmax,ymax));
    sz= Pt2di(round((mBoxGlob.P1().x-mBoxGlob.P0().x)/aGSD),round((mBoxGlob.P1().y-mBoxGlob.P0().y)/aGSD));
    aCorner=Pt2dr(mBoxGlob._p0.x,mBoxGlob._p1.y); // xmin, ymax;
    MTD.ResolutionPlani()=Pt2dr(aGSD,-aGSD);
    MTD.OriginePlani()=Pt2dr(xmin,ymax);

    // split ground footprint in tile if too large
    SplitInTiles();
}


void c_Appli_FeatheringAndMosaic::GenLabelTable()
{
    std::cout << "Divide mosaic space between every ortho (label map generation) based on their incidence.\n";
    std::string fileDicoLab(mLabel.substr(0,mLabel.size()-4)+"-Dico.txt");
    FILE * aFOut = FopenNN(fileDicoLab.c_str(),"w","out");

    for (auto &aBox : mTiles) {
    int idBox=aBox.first;
    Box2di box=aBox.second;
    Pt2di aSz(box.P1().x-box.P0().x,box.P1().y-box.P0().y);
    Pt2dr corner=Pt2dr(aCorner.x+box.P0().x*MTD.ResolutionPlani().x,
                       aCorner.y+box.P0().y*MTD.ResolutionPlani().y);

    if (mTiling) std::cout << "Tile number " << idBox << ".\n";

    Im2D_U_INT2 ImLabel(aSz.x,aSz.y,65535);
    Im2D_REAL4 ImScoreIncid(aSz.x,aSz.y,100.0);

    int imLab(0);
    for (auto &im : mLFile)
    {
        if(idBox==0) fprintf(aFOut,"%s %i\n", im.c_str(),imLab); // only first tile

        std::string incidName=mDir+KeyAssocNameOrt2Incid(im);
        std::string TFWName=KeyAssocNameTif2TFW(im);
        std::string pcName=mDir+KeyAssocNameOrt2PC(im);

        // load the incidence map and hidden part map
        // le tfw convient pour im masque PC mais par pour de l'image incid qui est sous resolue.     
        cImGeo Masq(pcName,TFWName);
        mTrs[imLab]= Masq.computeTrans(aCorner);// translation between ortho and corner of the complete mosaic
        // current orto instersect box?
        if(box.contains(-mTrs[imLab]) | box.contains(-mTrs[imLab]+Masq.SzUV())){

        Im2D_REAL4 imPC=Masq.toRAM();

        // avoid border problem (eg from inapropriate incid value on the edge) by shrinking the mask image
        Im2D_U_INT1 iBin(imPC.sz().x,imPC.sz().y,0);
        Neighbourhood V8 = Neighbourhood::v8();
        ELISE_COPY(select(iBin.all_pts(),imPC.in()>mMasqLim),1,iBin.out());
        ELISE_COPY(iBin.border(2),0,iBin.out());
        ELISE_COPY
        (
        dilate
        (
        select(imPC.all_pts(),iBin.in()==1),
        V8
        ),
        255,
        imPC.out()
        );

        cMetaDataPartiesCachees MTD = StdGetFromSI(KeyAssocNamePC2MTD(pcName),MetaDataPartiesCachees);
        int aFact=MTD.SsResolIncH().Val();

        Im2D_REAL4 imIncid=Im2D_REAL4::FromFileStd(incidName);
        // try to correct wierd value in the incid map
        ELISE_COPY(select(imIncid.all_pts(),(imIncid.in()>3.14)|(imIncid.in()<0)),
                   3.14,
                   imIncid.out());

        TIm2D<REAL4,REAL> mTScLoc(imIncid);


        Pt2di aP;

       // same incid map so no reason to save it again ,expect maybe the tfw (that have not the same resol)
        if (mDebug) writeTFW(KAIncidName(im,mTmpDir),Pt2dr(Masq.GSD()*aFact,-Masq.GSD()*aFact),Pt2dr(Masq.OriginePlani().x,Masq.OriginePlani().y));
        for (aP.x =0 ; aP.x < Masq.SzUV().x ; aP.x++)
        {
            for (aP.y =0 ; aP.y < Masq.SzUV().y ; aP.y++)
            {
                double aValIncid=mTScLoc.getr(Pt2dr(aP)/aFact,10e3);
                Pt2di aPinMosaic = aP-mTrs[imLab];
                if ((imPC.GetR(aP) < mMasqLim) && (aValIncid<3) && (aValIncid>=0) && box.contains(aPinMosaic))
                {
                    Pt2di aPinMosaicTile=aPinMosaic-box.P0();
                    double aScore = ImScoreIncid.GetR(aPinMosaicTile);

                    if (aScore>aValIncid)// incid should be as low as possible
                    {
                        ImLabel.SetR(aPinMosaicTile,imLab);
                        ImScoreIncid.SetR(aPinMosaicTile,aValIncid);
                    }
                }
            }
        }
        }
        imLab++;
    }
    if(idBox==0) ElFclose(aFOut);
    // save label map and tfw file

    std::string aNameLabel, aNameIncid("IncidScore.tif");
    if (!mTiling){
    aNameLabel=mLabel;
    } else {
    aNameIncid=KAtifNameTile(aNameIncid,idBox);
    aNameLabel=KAtifNameTile(mLabel,idBox);
    }

    if (ELISE_fp::exist_file(aNameLabel)) std::cout << "I overwrite file " << aNameLabel << "\n";
    ELISE_fp::RmFileIfExist(aNameLabel);
    Tiff_Im::CreateFromIm(ImLabel,aNameLabel);
    writeTFW(aNameLabel, MTD.ResolutionPlani(),corner);

    if (mDebug) {
        Tiff_Im::CreateFromIm(ImScoreIncid,mTmpDir+aNameIncid);
        writeTFW(mTmpDir+aNameIncid, MTD.ResolutionPlani(),corner);
    }
    // end for every tile
    }
}

void c_Appli_FeatheringAndMosaic::checkParam()
{
    if ((mDist>244) | (mDist<0))
    {
        std::cout << "Warning, feathering distance have to be between [0-255[. I reset it to an appropriate value.\n";
        mDist=50;
    }

    if ((mLambda<0) | (mLambda > 1))
    {
        std::cout << "Warning, lambda have to be between [0-1]. I reset it to an appropriate value.\n";
        mLambda=0.4;
    }

    if ((EAMIsInit(&mLabel)) && (!ELISE_fp::exist_file(mLabel)))
    {
        std::cout << "Warning, you have provided a label map (" << mLabel << ") but I can not find the file.\n";
    }

    if (mComputeRE) {
        mDoRE=1;
    }
}

void c_Appli_FeatheringAndMosaic::GenerateTiff()
{

    for (auto &aBox : mTiles) {
        int idBox=aBox.first;
        Box2di box=aBox.second;
        std::string NameMosaicOut=KAtifNameTile(mNameMosaicOut,idBox);
        ELISE_fp::RmFileIfExist(NameMosaicOut);

        Pt2di aSz(box.P1().x-box.P0().x,box.P1().y-box.P0().y);

        Pt2dr corner=Pt2dr(aCorner.x+box.P0().x*MTD.ResolutionPlani().x,
                           aCorner.y+box.P0().y*MTD.ResolutionPlani().y);
                           //boxMosaic._p1.y+mBox.P0().y*MTD.ResolutionPlani().y
        Tiff_Im  aTF(NameMosaicOut.c_str(),aSz,GenIm::real4, Tiff_Im::No_Compr, Tiff_Im::BlackIsZero);
        writeTFW(NameMosaicOut, MTD.ResolutionPlani(),corner);

        if (mDebug)
        {
            if (!ELISE_fp::IsDirectory(mTmpDir)) ELISE_fp::MkDir(mTmpDir);
            Tiff_Im  aNbIm(KAtifNameTile(nameNbIm(),idBox).c_str(),aSz,GenIm::int1, Tiff_Im::No_Compr, Tiff_Im::BlackIsZero);
            writeTFW(KAtifNameTile(nameNbIm(),idBox), MTD.ResolutionPlani(),corner);
            Tiff_Im  aSumDistInterne(KAtifNameTile(nameSDI(),idBox).c_str(),aSz,GenIm::int2, Tiff_Im::No_Compr, Tiff_Im::BlackIsZero);
            writeTFW(KAtifNameTile(nameSDI(),idBox), MTD.ResolutionPlani(),corner);
            Tiff_Im  aSumDistExterne(KAtifNameTile(nameSDE(),idBox).c_str(),aSz,GenIm::int2, Tiff_Im::No_Compr, Tiff_Im::BlackIsZero);
            writeTFW(KAtifNameTile(nameSDE(),idBox), MTD.ResolutionPlani(),corner);
            Tiff_Im  aSumWeighting(KAtifNameTile(nameSW(),idBox).c_str(),aSz,GenIm::real4, Tiff_Im::No_Compr, Tiff_Im::BlackIsZero);
            writeTFW(KAtifNameTile(nameSW(),idBox), MTD.ResolutionPlani(),corner);
            Tiff_Im  aInternalWeighting(KAtifNameTile(nameIW(),idBox).c_str(),aSz,GenIm::real4, Tiff_Im::No_Compr, Tiff_Im::BlackIsZero);
            writeTFW(KAtifNameTile(nameIW(),idBox), MTD.ResolutionPlani(),corner);
        }
    }

}

// key assoc name tiff for each tile
std::string cMyICNM::KAtifNameTile(std::string aTifName, int idBox)
{
    std::string Name;
    if (mTiling){
    Name=aTifName.substr(0, aTifName.size()-4)+"_Tile"+ToString(idBox)+".tif";
    }else { Name=aTifName;}
    return Name;
}

void c_Appli_FeatheringAndMosaic::SplitInBoxes()
{
    int i(0);
    for (auto &aTile : mTiles){
    int idBox=aTile.first;
    Box2di box=aTile.second;
    Pt2di aSz(box.P1().x-box.P0().x,box.P1().y-box.P0().y);


    int nbL=round_up((double)aSz.y/mSzTuile.y);
    int nbC=round_up((double)aSz.x/mSzTuile.x);

    for (int l(0); l<nbL;l++)
    {
        for (int c(0); c<nbC;c++)
        {
            // box calcul dans la geometrie de la Mosaique globale
            int dxMin(-mDilat),dxMax(+mDilat),dyMin(-mDilat),dyMax(+mDilat);
            int xMin=ElMax(0,box.P0().x+c*mSzTuile.x-mDilat);
            if (xMin==0) dxMin=0;
            int xMax=ElMin(sz.x,box.P0().x+(c+1)*mSzTuile.x+mDilat);
            if (xMax==sz.x) dxMax=0;
            int yMin=ElMax(0,box.P0().y+l*mSzTuile.y-mDilat);
            if (yMin==0) dyMin=0;
            int yMax=ElMin(sz.y,box.P0().y+(l+1)*mSzTuile.y+mDilat);
            if (yMax==sz.y) dyMax=0;
            Box2di aBox(Pt2di(xMin,yMin),Pt2di(xMax,yMax));
            Box2di aDilat(Pt2di(dxMin,dyMin),Pt2di(dxMax,dyMax));

            // select images that will be used for each box and save image list in xml file
            // read all different value in label map

            Liste_Pts_INT2 lpt(3);

            label=Im2D_U_INT2::FromFileStd(KAtifNameTile(mLabel,idBox));
            // une box de calcul va nécessiter plusieurs tuile car dilatation de bord pour éviter effet de bord.
            // une box de calcul peut déborder d'une tuile Im2D label
            // box calcul dans la geometrie de la tuile
            Box2di boxGeomTile=Box2di(aBox.P0()-box.P0(), aBox.P1()-box.P0());

            ELISE_COPY(rectangle(boxGeomTile).chc(Virgule(FX,FY,label.in_proj())),
                       1,
                       lpt);

            std::vector<int> labs=extractImID(&lpt);

            if (labs.size()!=0){
                i++;
                mBoxes[i]=aBox;
                mDilatBoxes[i]=aDilat;
                mTileofBoxes[i]=idBox;

                std::string tile("");
                 if (mTiling) tile = " of Tile number " + ToString(idBox);
                std::cout << "Box number " << i << ": " << mBoxes[i] << tile << "\n";
                // create list of image and save it in xml file
                cListOfName aLON;
                for (auto & id : labs)
                {
                    std::list<std::string>::iterator it = std::next(mLFile.begin(), id);
                    aLON.Name().push_back(*it);
                }
                MakeFileXML(aLON,mDir+nameXmlImList(i));

            } else {
                if (mDebug) std::cout << "No image for box " << aBox << "\n";
            }
        }
    }
    mNbBox=i;
    }
    std::cout << "Split mosaic in  " << mNbBox << " boxes.\n";
}


void c_Appli_FeatheringAndMosaic::SplitInTiles()
{
    int nbL=round_up((double)sz.y/mSzTuileFile.y);
    int nbC=round_up((double)sz.x/mSzTuileFile.x);
    int i(0);

    for (int l(0); l<nbL;l++)
    {
        for (int c(0); c<nbC;c++)
        {
            int xMin=ElMax(0,c*mSzTuileFile.x);
            int xMax=ElMin(sz.x,(c+1)*mSzTuileFile.x);
            int yMin=ElMax(0,l*mSzTuileFile.y);
            int yMax=ElMin(sz.y,(l+1)*mSzTuileFile.y);
            Box2di aBox(Pt2di(xMin,yMin),Pt2di(xMax,yMax));
            mTiles[i]=aBox;

            std::cout << "Tile  " << i << ": footprint in pixel is " << aBox << "\n";
            i++;
        }
    }
    if (i>1) {
        std::cout << "Split resulting files in " << i << " Tiles.\n";
        mTiling=1;
        // rigth now, tiling not working with edge buffer
        std::cout << "Warn, tiling of result, edge effet may occur \n";
        mDilat=0;
    }
}

void c_Appli_FeatheringAndMosaic::DoMosaicAndFeather()
{
    std::list<std::string> aLCom;
    for (auto & boxMap :mBoxes)
    {
        int i(boxMap.first);
        Box2di box=boxMap.second;
        Box2di tile=mTiles[mTileofBoxes[i]];
        // box dans geom de la tuile
        if (mTiling) box=Box2di(box.P0()-tile.P0(), box.P1()-tile.P0());
        std::string tiling=(mTiling) ? " Tile="+ToString(mTileofBoxes[i]) : " ";


        std::string aCom =    MMBinFile(MM3DStr) + " TestLib SeamlineFeatheringBox "
                + "'"+mFullDir + "'  "
                + mNameMosaicOut + " "
                + mLabel + " "
                + ToString(box) + " "
                + ToString(mDilatBoxes[i]) + " "
                + mDir+nameXmlImList(i) + " "
                + ToString(i)
                + tiling
                + " Debug=" + ToString(mDebug)
                + " Lambda=" + ToString(mLambda)
                + " Dist=" + ToString(mDist)
                + " TmpDir=" + mTmpDir
                + " Message='Box num " + ToString(i) + " of " + ToString(mNbBox)+" " + tiling +  "'"
                ;
        if (mDoRE) aCom= aCom+ " FileRE=" + mFileModelsRadiomEgal;
        aLCom.push_back(aCom);
        if (mDebug) std::cout << aCom << "\n";
    }
    cEl_GPAO::DoComInParal(aLCom);
}

void c_Appli_FeatheringAndMosaic::banniereFeathering()
{
    std::cout <<  "\n";
    std::cout <<  " ************************************\n";
    std::cout <<  " *     No funcky name right now     *\n";
    std::cout <<  " *     Mosaiking of orthoimages     *\n";
    std::cout <<  " *     With feathering along        *\n";
    std::cout <<  " *     seamline                     *\n";
    std::cout <<  " ************************************\n\n";
    std::cout <<  "Lamda for gaussian distance (from seamline) weighting: " << mLambda << "\n";
    std::cout <<  "Chamfer 3-2 distance from seamline for feathering: " << mDist << "\n";
    std::cout <<  "Result file: " <<  mNameMosaicOut << "\n";
    std::cout <<  " ************************************\n\n";
}

int main_featheringOrtho(int argc,char ** argv)
{
    c_Appli_FeatheringAndMosaic(argc,argv);
    return EXIT_SUCCESS;
}

/*
 * my interface for name manipulation And tiff and tfw saving - all tools that have to be use by both appli "mother" and appli "box"
 *
 */

cMyICNM::cMyICNM()
{
    mTmpDir="Tmp-Mosaicking/";
    mDoRE=false;
    mDist=50; // distance chamfer of 50 for feathering/estompage
    mLambda=0.4;
    mDebug=0;
    mNameImList="MosaickingImList_Box";
    mNameNbIm="NbIm.tif";
    mNameInternalW="InternalWeighting.tif";
    mNameSumDistExt="SumDistExt.tif";
    mNameSumDistInt="SumDistInt.tif";
    mNameSumWeighting="SumWeighting.tif";
    mTiling=0;
}

std::string cMyICNM::KeyAssocNameOrt2PC(std::string aOrtName)
{
    std::string aKey= "Key-Assoc-OpIm2PC"  ;
    std::string Name = mICNM->Assoc1To1(aKey,aOrtName,true);
    return Name;
}
std::string cMyICNM::KeyAssocNameOrt2Incid(std::string aOrtName)
{
    std::string aKey= "Key-Assoc-OpIm2Incid"  ;
    std::string Name = mICNM->Assoc1To1(aKey,aOrtName,true);
    return Name;
}
std::string KeyAssocNameTif2TFW(std::string aOrtName)
{
    std::string TFWName=aOrtName.substr(0, aOrtName.size()-3)+"tfw";
    return TFWName;
}
std::string cMyICNM::KeyAssocNamePC2MTD(std::string aPCName)
{
    std::string XMLName=aPCName.substr(0, aPCName.size()-3)+"xml";
    return XMLName;
}
std::string cMyICNM::KAChamferName(std::string aImName,std::string aDir,int aBox)
{
    std::string ChamferName=aDir+"Box_"+ToString(aBox)+"_Chamfer_"+aImName;
    return ChamferName;
}
std::string cMyICNM::KAWeightingName(std::string aImName,std::string aDir,int aBox)
{
    std::string WeightingName=aDir+"Box_"+ToString(aBox)+"_W_"+aImName;
    return WeightingName;
}
std::string cMyICNM::KAIncidName(std::string aImName,std::string aDir)
{
    std::string IncidName=aDir+"Incid_"+aImName;
    return IncidName;
}

template <class T,class TB> void  cMyICNM::SaveBoxInTiff(std::string aName,  Im2D<T,TB> * aIm,Box2di aBox2Save,Box2di aBox)
{
    Tiff_Im  aTF (aName.c_str());

    ELISE_COPY(rectangle(aBox2Save),
               trans(aIm->in(0),-aBox._p0),
               aTF.out());
}

// write tfw for all resulting map
int writeTFW(std::string aNameTiffFile, Pt2dr aGSD, Pt2dr aXminYmax)
{
    std::string aNameTFW=KeyAssocNameTif2TFW(aNameTiffFile);
    std::ofstream aTFW(aNameTFW.c_str());
    aTFW.precision(12);
    aTFW << aGSD.x << "\n" << 0 << "\n";
    aTFW << 0 << "\n" <<  aGSD.y << "\n";
    aTFW << aXminYmax.x << "\n" << aXminYmax.y << "\n";
    aTFW.close();
    return EXIT_SUCCESS;
}

std::vector<int> cMyICNM::extractImID(Liste_Pts_INT2 * aListePt)
{
    unsigned int val;
    // tab is an array, number of the element == value of label. value of the bool: true: label exist. false. label do not exist.
    std::vector<bool> tab;
    std::vector<int> labs;
    Im2D_INT2 Im =  aListePt->image();
    INT2 ** d = Im.data();
    INT2 * aVal = d[2];

    for (int i(0); i<Im.tx();i++)
    {
        val=aVal[i];
        // i do not know why but they may have -1 value, that will create bug if not evacuated here with contidition val>=0
        // all the following code: to avoid to loop on the labs vector to check if value are on it or not
        if (val<65535 && val>=0)
        {
         if (val+1>tab.size())// + 1 because O is also a value
         {
         // rise the size of tab
         do tab.push_back(0); while (tab.size()<val+1);
         }
         // put a true in the tab at the correct position
         if (tab.at(val)==0) {
            tab.at(val)=1;
         }
        }
    }
    for (unsigned int i(0) ; i< tab.size();i++)
    {if (tab.at(i)==1) labs.push_back(i);}
    return labs;
}


std::map<int,int> cMyICNM::extractHist(Liste_Pts_INT2 * aListePt)
{
    unsigned int val;
    // tab is an array, number of the element == value of label. value of the bool: true: label exist. false. label do not exist.
    std::vector<int> tab;
    std::map<int,int> labs;
    Im2D_INT2 Im =  aListePt->image();
    INT2 ** d = Im.data();
    INT2 * aVal = d[2];

    for (int i(0); i<Im.tx();i++)
    {
        val=aVal[i];
        if (val<65535 && val>=0)
        {
         if (val+1>tab.size())// + 1 because O is also a value
         {
         // rise the size of tab
         do tab.push_back(0); while (tab.size()<val+1);
         }
         // add an occurence fot this observation
           tab.at(val)++;
        }
    }
    for (unsigned int i(0) ; i< tab.size();i++)
    {if (tab.at(i)>0) labs[i]=tab.at(i);}
    return labs;
}

/*
 *
 *
 *     Feather and mosaic for box
 *
 *
 */

cFeatheringAndMosaicOrtho::cFeatheringAndMosaicOrtho(int argc,char ** argv):lut_w(Im1D_REAL4(1,1)),mProgressBar(" No multiprocess mosaicking")
{

    mLabel="Label.tif";// from tawny tool
    mNameMosaicOut="MosaicFeathering.tif";

    ElInitArgMain
            (
                argc,argv,
                LArgMain()  << EAMC(mFullDir,"Ortho pattern", eSAM_IsPatFile)
                << EAMC(mNameMosaicOut,"Mosaic tif file." ,eSAM_IsExistFile)
                << EAMC(mLabel, "Label/index map.", eSAM_IsExistFile)
                << EAMC(mBox,"Box of the 4 corners [pix] of the tile to be processed.")
                << EAM(mDilat,"Buffer box [pix] to remove from each tile in order to avoid edge effect.")
                << EAMC(mListImFile,"XML file containing the list of images for this box.")
                << EAMC(mNumBox,"ID of the box")
                ,
                LArgMain()
                << EAM(mDist,"Dist",true, "Distance for seamline feathering blending, in chamfer 32 distance" )
                << EAM(mLambda,"Lambda",true, "lambda value for gaussian distance weighting, def 0.4." )
                << EAM(mDebug,"Debug",true, "Write intermediate results for debug purpose." )
                << EAM(mIdTile,"Tile",true, "Id of tile to write result." )
                << EAM(mTmpDir,"TmpDir",true, "Directory for intermediate results generated in debug mode." )
                << EAM(mProgressBar,"Message",true, "message that is printed - used as progress bar." )
                << EAM(mFileModelsRadiomEgal,"FileRE",true, "xml file of radiometric equalization models, if provided perform the equalisation prior to mosaicking." )
                );

    if (!MMVisualMode)
    {

        std::string aPatOrt;
        SplitDirAndFile(mDir,aPatOrt,mFullDir);
        mICNM = cInterfChantierNameManipulateur::BasicAlloc(mDir);
        MakeFileDirCompl(mTmpDir);

        if (EAMIsInit(&mIdTile)) {

            mTiling=1;
            // modify meaning of mBox, which is related to the tile and not to the global mosaic
            // la c'est mrd car je lisais la taille de la zone en lisant le nombre de pixel de label.tif, no way
            // sauver le MTD -appli global et le recharger?? oui c'est encore le plus simple
            // change name of input and output
            mNameMosaicOut=KAtifNameTile(mNameMosaicOut,mIdTile);
            mLabel=KAtifNameTile(mLabel,mIdTile);
            mNameNbIm=KAtifNameTile(mNameNbIm,mIdTile);
            mNameInternalW=KAtifNameTile(mNameInternalW,mIdTile);
            mNameSumDistExt=KAtifNameTile(mNameSumDistExt,mIdTile);
            mNameSumDistInt=KAtifNameTile(mNameSumDistInt,mIdTile);
            mNameSumWeighting=KAtifNameTile(mNameSumWeighting,mIdTile);

        }
        MTD =  TFW2FileOriMnt(KeyAssocNameTif2TFW(mLabel));
        Tiff_Im  aLabelGlob(mLabel.c_str());
        MTD.NombrePixels()=aLabelGlob.sz();

        // list of all images
        mLFile = mICNM->StdGetListOfFile(aPatOrt);
        // list of images used in this box
        if (ELISE_fp::exist_file(mListImFile))
        {
            cListOfName aLON =  StdGetFromPCP(mListImFile,ListOfName);
            for (auto & imName : aLON.Name())
            {
                // determine the id of this image
                unsigned int i(0);
                unsigned int id(0);
                for (auto & imName2 : mLFile)
                { if (imName==imName2){
                        id=i;
                        break;
                    }
                    i++;
                }
                mImNameBox[id]=imName;
                if (mDebug) std::cout << "Image " << imName << ": label " << id << "\n";
            }
        }

        if (EAMIsInit(&mFileModelsRadiomEgal)){
        if (ELISE_fp::exist_file(mFileModelsRadiomEgal))
        {loadREModels();} else { std::cout << "Warning, cannot find file " << mFileModelsRadiomEgal << ", i go on without radiometric equalization.\n";}
        }

        Box2dr boxMosaic(Pt2dr(MTD.OriginePlani().x,MTD.OriginePlani().y+MTD.ResolutionPlani().y*MTD.NombrePixels().y),Pt2dr(MTD.OriginePlani().x+MTD.ResolutionPlani().x*MTD.NombrePixels().x,MTD.OriginePlani().y));
        sz=Pt2di(mBox.P1().x-mBox.P0().x,mBox.P1().y-mBox.P0().y);
        aCorner=Pt2dr(boxMosaic._p0.x+mBox.P0().x*MTD.ResolutionPlani().x,boxMosaic._p1.y+mBox.P0().y*MTD.ResolutionPlani().y); // xmin, ymax;
        mBox2Save=Box2di(Pt2di(mBox.P0().x-mDilat.P0().x,mBox.P0().y-mDilat.P0().y),Pt2di(mBox.P1().x-mDilat.P1().x,mBox.P1().y-mDilat.P1().y));
        mosaic=Im2D_REAL4(sz.x,sz.y);

        // read a tile of an existing tiff file and copy it in im2D ram memory
        label=Im2D_U_INT2(sz.x,sz.y,65535);
        ELISE_COPY(label.all_pts(),
                   trans(aLabelGlob.in_proj(),mBox.P0()),
                   label.out());

        NbIm=Im2D_INT1(sz.x,sz.y);
        mSumDistExt=Im2D_INT2(sz.x,sz.y);
        mSumDistInter= Im2D_INT2(sz.x,sz.y);
        PondInterne=Im2D_REAL4(sz.x,sz.y);
        mSumWeighting=Im2D_REAL4(sz.x,sz.y);

        std::string aName;

        // look up table of weight
        lut_w=Im1D_REAL4(mDist+1);
        ELISE_COPY
                (
                    lut_w.all_pts(),
                    0.5+0.5*pow(0.5,pow((FX/((double)mDist-FX+1)),2*mLambda)),
                    lut_w.out()
                    );
        // replace by 1 distance over the threshold of mDist
        ELISE_COPY(select(lut_w.all_pts(),lut_w.in()>1),1,lut_w.out());


        // special case mDist=0 : no feathering, just mosaicking
        if (mDist>0)
        {

        // compute chamfer distance from seamline and determine the number of images for each xy location
        if (mDebug) std::cout << "Compute Chamfer Distance from seamline for each ortho\n";
        // this is also during this stage that images are loaded, mImW and mChamfer and mIm2Ds and mTrs are initiated
        ChamferDist4AllOrt();

        if (mDebug)
        {
            // save the map of number of image
            aName=nameNbIm();
            std::cout << "Save map of number of ortho used for each location , file " << aName << "\n";
            SaveBoxInTiff(aName,& NbIm,mBox2Save,mBox);
            aName=nameSDI();
            std::cout << "Save map of sum of chamfer distance inside enveloppe for each location , file " << aName << "\n";
            SaveBoxInTiff(aName,& mSumDistInter,mBox2Save,mBox);
            aName=nameSDE();
            std::cout << "Save map of sum of chamfer distance outside enveloppe for each location , file " << aName << "\n";
            SaveBoxInTiff(aName,& mSumDistExt,mBox2Save,mBox);
        }

        if (mDebug) std::cout << "Compute weighting for each orthoimage in blending zone with 2 images.\n";
        // compute the weighting for area where number of images is 1 or 2
        WeightingNbIm1and2();

        // Particular attention for area of 3 images overlapping.
        if (mDebug) std::cout << "Start monitoring of areas of 3 orthoimages blending (and sometime more)\n";
        WeightingNbIm3AndMore();

        if (mDebug)
        {
            // save the map of internal weighting
            aName=nameIW();
            std::cout << "Save map of internal weighting , file " << aName << "\n";
            SaveBoxInTiff(aName,& PondInterne,mBox2Save,mBox);
        }

        std::cout << "Compute mosaic by multipling orthoimage value by weighting map.\n";
        ComputeMosaic();


        if (mDebug)
        {
            aName=nameSW();
            std::cout << "Save map of sum of weighting, should be equal to 1 everywhere , file " << aName << "\n";
            SaveBoxInTiff(aName,& mSumWeighting,mBox2Save,mBox);
        }

        // case mDist=0
        } else {
        // no computation of chamfer dist or weighting ma, so saving of computational time
        std::cout << "Compute mosaic without feathering along seamline.\n";
        ComputeMosaicNoFeathering();

        }

        SaveBoxInTiff(mNameMosaicOut, & mosaic,mBox2Save,mBox);

        banniereFeatheringBox();
    }
}


// Chamfer::d32.im_dist compute chamfer distance from border of the image, i do not like that at all. this function add a border prior to compute chanfer distance and remove it afterward
void cFeatheringAndMosaicOrtho::ChamferNoBorder(Im2D<U_INT1,INT> i2d) const
{
    int border(200);
    Im2D_U_INT1 tmp(i2d.sz().x+2*border,i2d.sz().y+2*border,1);
    ELISE_COPY(select(tmp.all_pts(),trans(i2d.in(1),-Pt2di(border,border))==0),0,tmp.out());
    Chamfer::d32.im_dist(tmp);
    ELISE_COPY(i2d.all_pts(),trans(tmp.in(255),Pt2di(border,border)),i2d.oclip());
}


void cFeatheringAndMosaicOrtho::ChamferDist4AllOrt()
{

    for (auto &imMap : mImNameBox)
    {
        unsigned int i(imMap.first); // i is the label of the image - and the key for map object
        std::string im(imMap.second);
        if (mDebug) std::cout << "Image num " << i << " is " << im <<" : loading and computing feathering buffer.\n";
        // open orthos
        mIms[i]= new cImGeo(mDir+im);
        mIm2Ds[i]=  mIms[i]->toRAM();
        Pt2di aSz(mIms[i]->Im().sz());
        mChamferDist[i]=Im2D_INT2(aSz.x,aSz.y,1);
        mImWs[i]=Im2D_REAL4(aSz.x,aSz.y,0.0);
        mTrs[i]= -mIms[i]->computeTrans(aCorner);

        // la fonction chamfer fonctionne sur une image binaire et va calculer les distance à partir des pixels qui ont une valeur de 0.
        // la distance maximale est de 255

        //detect seam line for this image
        //1) translation of label to be in ortho geometry and set value to 0 for points that are not inside area of mosaicking for this image
        Im2D_U_INT1 tmp(aSz.x,aSz.y,1);

        ELISE_COPY(select(tmp.all_pts(), trans(label.in(65535),mTrs[i])!=(int)i),
                   0,
                   tmp.out()
                   );

        // remove very small patch for which we do not want to perform feathering INSIDE because it is ugly otherwise
        // I should maybe stop the feathering outside such small area as well
        Im2D_U_INT1 Ibin(tmp.sz().x,tmp.sz().y,0);
        ELISE_COPY(Ibin.all_pts(),tmp.in(),Ibin.out());
        // I have to ensure the border of the bin image is not ==1 otherwise I got the error out of bitmap in dilate spec Image
        ELISE_COPY(Ibin.border(2),0,Ibin.out());
        U_INT1 ** d = Ibin.data();
        Neighbourhood V8=Neighbourhood::v8();

        for (INT x=0; x < Ibin.sz().x; x++)
        {
            for (INT y=0; y < Ibin.sz().y; y++)
            {
                if (d[y][x] == 1)
                {
                    Liste_Pts_INT2 cc(2);
                    ELISE_COPY
                            (
                                // flux: composantes connexes du point.
                                conc
                                (
                                    Pt2di(x,y),
                                    Ibin.neigh_test_and_set(V8, 1, 0,  10) ), // on change la valeur des points sélectionné comme ça à la prochaine itération on ne sélectionne plus cette zone de composante connexe
                                2, // valeur bidonne, c'est juste le flux que je sauve dans cc
                                cc
                                );
                    // remove the patch: if it is smal, note these pixel as been not in the image, this way no chamfer dist are computed inside
                    if (cc.card()<pow(mDist,2)) ELISE_COPY(cc.all_pts(),0,tmp.out());
                }
            }
        }

        // compute chamfer Distance d32
        ChamferNoBorder(tmp);

        // inverse value of distance because this is inside the enveloppe
        ELISE_COPY(mChamferDist[i].all_pts(),-tmp.in(),mChamferDist[i].out());

        // Initialise tmp again
        ELISE_COPY(tmp.all_pts(),1,tmp.out());
        ELISE_COPY(
                    select(mChamferDist[i].all_pts(),mChamferDist[i].in()==-2),// distance ==-2 are pixels on the seamline (more or less)
                    0,
                    tmp.out());
        // chamfer distance outside the enveloppe
        ChamferNoBorder(tmp);

        ELISE_COPY(
                    select(mChamferDist[i].all_pts(),mChamferDist[i].in()==0),
                    tmp.in(),
                    mChamferDist[i].out());

        // apply the hidden part masq
        std::string aNamePC=mDir+KeyAssocNameOrt2PC(im);
        Im2D_U_INT1 masq=Im2D_U_INT1::FromFileStd(aNamePC);

        // apply the mask of the ortho and the mask of the label
        ELISE_COPY(
                    select(mChamferDist[i].all_pts(),masq.in()==255) || select(mChamferDist[i].all_pts(), trans(label.in(65535),mTrs[i])==65535),
                    255,
                    mChamferDist[i].out());

        // save chamfer map for checking purpose
        if (mDebug)
        {
            Tiff_Im::CreateFromIm(mChamferDist[i],KAChamferName(im,mTmpDir,mNumBox));
            // save TFW file
            mIms[i]->writeTFW(KAChamferName(im,mTmpDir,mNumBox));
        }
        // comptage du nombre d'image a utiliser pour le blending (geométrie mosaic)
        ELISE_COPY(select(NbIm.all_pts(),trans(mChamferDist[i].in(mDist+1),-mTrs[i])<=mDist),
                   NbIm.in(0)+1,
                   NbIm.out()
                   );
        // somme des distances de chamber dans les enveloppes externes  - pour gérer les cas de blending de 3 images (et plus)
        ELISE_COPY(select(mSumDistExt.all_pts(),(trans(mChamferDist[i].in_proj(),-mTrs[i])<=mDist ) && ( trans(mChamferDist[i].in_proj(),-mTrs[i])>0 ) ),
                   mSumDistExt.in(0)+trans(mChamferDist[i].in(0),-mTrs[i]),
                   mSumDistExt.out()
                   );
        // Distance de chamber dans les enveloppes inter - également pour gérer les cas de blending de 3 images
        ELISE_COPY(select(mSumDistInter.all_pts(),(trans(mChamferDist[i].in_proj(),-mTrs[i])>=-mDist) && ( trans(mChamferDist[i].in_proj(),-mTrs[i])<0)),
                   mSumDistInter.in(0)+trans(mChamferDist[i].in(0),-mTrs[i]),
                   mSumDistInter.out()
                   );
    }
}

void cFeatheringAndMosaicOrtho::WeightingNbIm1and2()
{

    //  pondération contribution de l'image à l'intérieur de son enveloppe; je peux effectuer le calcul du facteur de pondération pour toutes les images d'un coup
    if (mDebug) std::cout << "Computing weighting in overlap NbIm=1 and 2\n";

    // NbIm==1
    ELISE_COPY(select(PondInterne.all_pts(),NbIm.in ()==1),
               1,
               PondInterne.out()
               );
    // NbIm==2, feathering dans l'enveloppe interne
    ELISE_COPY(select(PondInterne.all_pts(), (NbIm.in()==2) && mSumDistInter.in() <=0 && mSumDistInter.in()>=-mDist),
                lut_w.in()[mDist+mSumDistInter.in()],
                PondInterne.out()
            );

    // generate every image weighting
    for (auto &imMap : mImNameBox)
    {
        unsigned int i(imMap.first);
        // internal enveloppe
        ELISE_COPY(select(mImWs[i].all_pts(),mChamferDist[i].in(0)<=0),
                   trans(PondInterne.in(0),mTrs[i]),
                   mImWs[i].out()
                   );
        // external enveloppe
        ELISE_COPY(select(mImWs[i].all_pts(),(mChamferDist[i].in(0)>0)  && (mChamferDist[i].in(0)<=mDist) && ((trans(NbIm.in(0),mTrs[i])==1) |(trans(NbIm.in(0),mTrs[i])==2))),
                   1-trans(PondInterne.in(0),mTrs[i]),
                   mImWs[i].out()
                   );
    }
}

void cFeatheringAndMosaicOrtho::WeightingNbIm3AndMore()
{
    Im2D_U_INT1 Ibin(sz.x,sz.y,0);
    ELISE_COPY(select(Ibin.all_pts(),NbIm.in()>=3), 1,Ibin.out());
    // on border, width of 2 pixels, trash value that ensure that neighbour analyse tool will never go outside the image
    ELISE_COPY(border_rect(Pt2di(0,0),Ibin.sz(),2),0,Ibin.out());

    U_INT1 ** d = Ibin.data();
    int count_O3(0); // counter for number of area of 3 images (or more) overlapping
    Neighbourhood V8=Neighbourhood::v8();

    for (INT x=0; x < Ibin.sz().x; x++)
    {
        for (INT y=0; y < Ibin.sz().y; y++)
        {
            if (d[y][x] == 1)
            {
                count_O3++;
                Liste_Pts_INT2 cc(2);
                ELISE_COPY
                        (
                            conc
                            (
                                Pt2di(x,y),
                                Ibin.neigh_test_and_set(V8, 1, 0,  20) ),
                            1,
                            cc
                            );
                // determine la boite englobante
                Pt2di pmax,pmin;
                // temporary map enabling a quick selection of these pixels
                Im2D_INT2    CurrentArea(sz.x,sz.y,0);
                ELISE_COPY
                        (
                            cc.all_pts(),
                            Virgule(FX,FY),
                            ((pmax.VMax())|(pmin.VMin())) );

                ELISE_COPY
                        (
                            cc.all_pts(),
                            1,
                            CurrentArea.out());

                // retrieve image label for these area
                Liste_Pts_INT2 lpt(3);
                ELISE_COPY(cc.all_pts().chc(Virgule(FX,FY,label.in())),
                           1,
                           lpt);
                std::vector<int> labs=extractImID(&lpt);


                if (labs.size()==3){
                if (mDebug) std::cout << "I got the 3 images for an ovelap area (id: " << count_O3 << "), images labels are " << labs <<"\n";

                // load 3 chamfer distance for ease of manipulation
                // I do not know why but i have to add 1 to the length
                Pt2di beSz(pmax.x-pmin.x+1,pmax.y-pmin.y+1);
                //std::cout << "size of the area : " << beSz << ", location on the global orthophoto : " << pmin << " and " << pmax <<"\n";
                Im2D_INT2 dist1(beSz.x,beSz.y),dist2(beSz.x,beSz.y),dist3(beSz.x,beSz.y);
                Im2D_REAL4 gateau12(beSz.x,beSz.y);
                Pt2di tr0 = -mTrs[labs[0]]+pmin;// double translation, une vers le système global, une vers la boite englobante de la zone
                ELISE_COPY(dist1.all_pts(),trans(mChamferDist[labs[0]].in(0),tr0),dist1.out());
                Pt2di tr1 = -mTrs[labs[1]]+pmin;
                ELISE_COPY(dist2.all_pts(),trans(mChamferDist[labs[1]].in(0),tr1),dist2.out());
                Pt2di tr2 = -mTrs[labs[2]]+pmin;
                ELISE_COPY(dist2.all_pts(),trans(mChamferDist[labs[2]].in(0),tr2),dist3.out());

                // strategy; firt im1 and im2 are blended, then im3 with the blend of im1 im2. but in fact, process first im3

                // feathering dans l'enveloppe interne de l'image numéro 3
                Pt2di tr = -mTrs[labs[2]];
                ELISE_COPY(select(mImWs[labs[2]].all_pts(), (mChamferDist[labs[2]].in()<=0) && (trans(CurrentArea.in(0),-tr)==1)),
                         lut_w.in()[mDist+mChamferDist[labs[2]].in()],
                        mImWs[labs[2]].out()
                        );
                // feathering dans l'enveloppe externe de l'image numéro 3
                ELISE_COPY(select(mImWs[labs[2]].all_pts(), (mChamferDist[labs[2]].in()>0) && (mChamferDist[labs[2]].in()<=mDist) && (trans(CurrentArea.in(0),-tr)==1)),
                        1-lut_w.in()[mDist-mChamferDist[labs[2]].in()],
                        mImWs[labs[2]].out()
                        );
                // copie de ceci dans PondInterne
                ELISE_COPY(select(PondInterne.all_pts(), (CurrentArea.in()==1) && (trans(mChamferDist[labs[2]].in(0),tr)<=0)),
                        trans(mImWs[labs[2]].in(0),tr),
                        PondInterne.out()
                        );

                ELISE_COPY(gateau12.all_pts(),0,gateau12.out());
                ELISE_COPY(select(gateau12.all_pts(), trans(CurrentArea.in(),pmin)==1),
                           1-trans(mImWs[labs[2]].in(0),tr2),
                        gateau12.out()
                        );

                // ok, im1 with im2 now
                //redefinition of a seamline between the two images, seamline on the enveloppe of the 3th image
                Im2D_U_INT1  tmp(beSz.x,beSz.y,1);
                Im2D_INT2    NewDist(beSz.x,beSz.y,1);
                ELISE_COPY((select(tmp.all_pts(),dist1.in()==dist2.in()) ) || (select(tmp.all_pts(),(dist1.in()==-2) && (dist2.in()<5))),
                           0,
                           tmp.out()
                           );
                ChamferNoBorder(tmp);

                ELISE_COPY(select(dist1.all_pts(),dist1.in()>dist2.in()),tmp.in(),NewDist.out());
                ELISE_COPY(select(dist1.all_pts(),dist1.in()<=dist2.in()),-tmp.in(),NewDist.out());

                // Now I got my new seamline between 1 and 2 and my new chamfer distance, negative inside envelope, positive outside

                // env interne im 1
                Im2D_REAL4 w0(beSz.x,beSz.y),w1(beSz.x,beSz.y);
                ELISE_COPY(w0.all_pts(),0,w0.out());
                ELISE_COPY(select(NewDist.all_pts(), (NewDist.in()<=0) && (NewDist.in()>=-mDist)),
                           gateau12.in() * (lut_w.in()[mDist+NewDist.in()]),
                        w0.out()
                        );
                ELISE_COPY(select(NewDist.all_pts(),(NewDist.in()>0) && (NewDist.in()<=mDist)),
                           gateau12.in() * (1 - lut_w.in()[mDist-NewDist.in()]),
                        w0.out()
                        );
                ELISE_COPY(w1.all_pts(),gateau12.in()-w0.in(),w1.out());

                //copy these weighting in the mImWs

                ELISE_COPY( mImWs[labs[0]].all_pts(),
                        mImWs[labs[0]].in() + trans(w0.in(0),mTrs[labs[0]]-pmin),
                        mImWs[labs[0]].out()
                        );

                ELISE_COPY( mImWs[labs[1]].all_pts(),
                        mImWs[labs[1]].in() + trans(w1.in(0),mTrs[labs[1]]-pmin),
                        mImWs[labs[1]].out()
                        );
                /* Display area with 3 images -- not so useful so I comment everything
                if (mDebug)
                {
                    std::string aName;
                    aName="Box_" + ToString(mNumBox) +"_O3Num" + ToString(count_O3) + "_part_12.tif";
                    Tiff_Im::CreateFromIm(gateau12,mTmpDir+aName);
                    // plani origin of this small area in order to generate the tfw file
                    Pt2dr corner(aCorner.x+pmin.x*MTD.ResolutionPlani().x,aCorner.y+pmin.y*MTD.ResolutionPlani().y);
                    mKA->writeTFW(mTmpDir+aName, MTD.ResolutionPlani(),corner);
                    aName="Box_" + ToString(mNumBox) +"_O3Num" + ToString(count_O3) + "_Dist1.tif";
                    Tiff_Im::CreateFromIm(dist1,mTmpDir+aName);
                    mKA->writeTFW(mTmpDir+aName, MTD.ResolutionPlani(),corner);
                    aName="Box_" + ToString(mNumBox) +"_O3Num" + ToString(count_O3) + "_Dist2.tif";
                    Tiff_Im::CreateFromIm(dist2,mTmpDir+aName);
                    mKA->writeTFW(mTmpDir+aName, MTD.ResolutionPlani(),corner);
                    aName="Box_" + ToString(mNumBox) +"_O3Num" + ToString(count_O3) + "_W0.tif";
                    Tiff_Im::CreateFromIm(w0,mTmpDir+aName);
                    mKA->writeTFW(mTmpDir+aName, MTD.ResolutionPlani(),corner);
                    aName="Box_" + ToString(mNumBox) +"_O3Num" + ToString(count_O3) + "_W1.tif";
                    Tiff_Im::CreateFromIm(w1,mTmpDir+aName);
                    mKA->writeTFW(mTmpDir+aName, MTD.ResolutionPlani(),corner);
                    aName="Box_" + ToString(mNumBox) +"_O3Num" + ToString(count_O3) + "_NewDist.tif";
                    Tiff_Im::CreateFromIm(NewDist,mTmpDir+aName);
                    mKA->writeTFW(mTmpDir+aName, MTD.ResolutionPlani(),corner);
                }
                */
            } else {
            if (labs.size()!=3 && labs.size()!=1){

             // less than 3 labs: patch of 3 images overlap that have been cutted by a patch of more than 3.
             // more than 3: patches of 3 images that have been merge in one single patch

            if (mDebug) std::cout << "Processing an area with probably more than 3 images to blend, images labels are " << labs <<"\n";

                for (auto & j : labs)
                {
                 for (int k(0);k<cc.image().sz().x;k++){
                 Pt2di pt(cc.image().GetR(Pt2di(k,0)),cc.image().GetR(Pt2di(k,1)));
                 if (mChamferDist[j].Inside(pt-mTrs[j])){
                 //inside or outside enveloppe?
                 int valD=mChamferDist[j].GetR(pt-mTrs[j]);
                 double w(0.0);

                 if (valD<0) {
                    //  inside envellope
                     w=lut_w.At(mDist+valD);
                 } else if (valD>0 && valD<=mDist){
                     // outside envellope
                     //1 read value of internal env.
                     int IntDist=mSumDistInter.GetI(pt);
                     //2 read value of SumDistExt
                     int SumDistExt=mSumDistExt.GetI(pt);
                     //3 retrieve weighting of internal env and share the rest as a ratio dist/SumDist
                     w=(1-lut_w.At(mDist+IntDist))  *   valD/SumDistExt;
                 }
                 mImWs[j].SetR(pt-mTrs[j],w);
                 }
                 // end for each pixel of the patch
                 }
                 // end for each image label
                }
             // end if no 3 labs
            } else  {
            if (labs.size()==1){
                // again, very scare case where area NbIm==3 have been "cutted" by an area with NbIm>3
                for (int k(0);k<cc.image().sz().x;k++){
                Pt2di pt(cc.image().GetR(Pt2di(k,0)),cc.image().GetR(Pt2di(k,1)));
                // weighting =1
                mImWs[labs[0]].SetR(pt-mTrs[labs[0]],1);
                }
            }
            }
            // end if labs.size==3
            }
        // end processing of the patch
        }
     // end for each colum pixel of the mosaic
    }
// end for each row pixel of the mosaic
}
// end void
}


Fonc_Num RE(Fonc_Num f,double a, double b)
{
return a+b*f;
}


void cFeatheringAndMosaicOrtho::ComputeMosaic()
{
    for (auto &imMap : mImNameBox)
    {
        unsigned int i(imMap.first);
        std::string im(imMap.second);
        // mosaic
        if (mDoRE){
        ELISE_COPY(select(mosaic.all_pts(),trans(mImWs[i].in(0),-mTrs[i])>0),
                   mosaic.in()+trans(RE(mIm2Ds[i].in(),mREMs[i].getA(),mREMs[i].getB())*mImWs[i].in(),-mTrs[i]) ,
                   mosaic.out()
                   );
        } else {
        ELISE_COPY(select(mosaic.all_pts(),trans(mImWs[i].in(0),-mTrs[i])>0),
                   mosaic.in()+trans(mIm2Ds[i].in()*mImWs[i].in(),-mTrs[i]) ,
                   mosaic.out()
                   );
        }
        // sum of weighting, to check it is well equal to 1 everywhere
        if (mDebug)
        {
            ELISE_COPY(select(mSumWeighting.all_pts(),trans(mImWs[i].in(0),-mTrs[i])>0),
                       mSumWeighting.in()+trans(mImWs[i].in(0),-mTrs[i]) ,
                       mSumWeighting.out()
                       );
            // individual weighting
            Tiff_Im::CreateFromIm(mImWs[i],KAWeightingName(im,mTmpDir,mNumBox));
            mIms[i]->writeTFW(KAWeightingName(im,mTmpDir,mNumBox));
        }
    }
}

void cFeatheringAndMosaicOrtho::ComputeMosaicNoFeathering()
{
    for (auto &imMap : mImNameBox)
    {
        unsigned int i(imMap.first);
        std::string im(imMap.second);
        mIms[i]= new cImGeo(mDir+im);
        mIm2Ds[i]=  mIms[i]->toRAM();
        mTrs[i]= -mIms[i]->computeTrans(aCorner);
        // mosaic
        if (mDoRE){
        ELISE_COPY(select(mosaic.all_pts(),label.in()==(int)i),
                   mosaic.in()+trans(RE(mIm2Ds[i].in(),mREMs[i].getA(),mREMs[i].getB()),-mTrs[i]) ,
                   mosaic.out()
                   );
        } else {
        ELISE_COPY(select(mosaic.all_pts(),label.in()==(int)i),
                   mosaic.in()+trans(mIm2Ds[i].in(),-mTrs[i]) ,
                   mosaic.out()
                   );
        }
    }
}

void cFeatheringAndMosaicOrtho::loadREModels()
{
    std::cout << "Load Radiometric Egalization models \n";
    mDoRE=1;
    cListOfRadiomEgalModel LREM;
    LREM=StdGetFromPCP(mFileModelsRadiomEgal,ListOfRadiomEgalModel);

    for (auto &imMap : mImNameBox)
    {
        unsigned int i(imMap.first);
        std::string imName(imMap.second);
        bool RE_ok(false);
        // find the model in the LREM
        //for (auto modlin : LREM)
        for( std::list< cModLin >::const_iterator modlin=LREM.ModLin().begin();
                 modlin!=LREM.ModLin().end();          modlin++    )
        {
            if (modlin->NameIm()==imName)
            {
                // add it in the map for subsequent use
                mREMs[i]=c2DLineModel(modlin->a(),modlin->b());
                RE_ok=true;
                break;
            }
        }

        if (!RE_ok) {
            mREMs[i]=c2DLineModel();
            std::cout << "I haven't found any model of radiometric equalization for orthoimage " << imName << " \n";
        }
    }
}

void cFeatheringAndMosaicOrtho::banniereFeatheringBox()
{
    std::cout <<  "\n";
    std::cout <<  " ************************************\n";
    std::cout <<  " *  Mosaic and feather orthoimage   *\n";
    std::cout <<  " * " <<      mProgressBar      <<" *\n";
    std::cout <<  " Number of orthoimages in the mosaic box: " << mIms.size() << "\n";
    std::cout <<  " ************************************\n\n";
}

int main_featheringOrthoBox(int argc,char ** argv)
{
    cFeatheringAndMosaicOrtho(argc,argv);
    return EXIT_SUCCESS;
}
